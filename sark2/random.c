
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include "constants.h"
#include "communication.h"
#include "random.h"

uint32_t kiss_x, kiss_y, kiss_z, kiss_c;

const float invcdf[257] = {
    0.000000, 0.004867, 0.009735, 0.014602, 0.019470, 0.024339, 0.029208, 0.034077,
    0.038948, 0.043819, 0.048692, 0.053565, 0.058440, 0.063317, 0.068194, 0.073074,
    0.077955, 0.082838, 0.087723, 0.092610, 0.097499, 0.102391, 0.107285, 0.112182,
    0.117081, 0.121983, 0.126888, 0.131796, 0.136708, 0.141622, 0.146540, 0.151462,
    0.156387, 0.161316, 0.166249, 0.171186, 0.176128, 0.181073, 0.186023, 0.190977,
    0.195937, 0.200901, 0.205870, 0.210844, 0.215823, 0.220808, 0.225798, 0.230794,
    0.235795, 0.240803, 0.245816, 0.250836, 0.255862, 0.260894, 0.265933, 0.270979,
    0.276032, 0.281092, 0.286159, 0.291233, 0.296315, 0.301405, 0.306502, 0.311607,
    0.316721, 0.321843, 0.326973, 0.332112, 0.337259, 0.342416, 0.347582, 0.352757,
    0.357941, 0.363135, 0.368339, 0.373553, 0.378777, 0.384012, 0.389257, 0.394512,
    0.399779, 0.405057, 0.410346, 0.415646, 0.420959, 0.426283, 0.431619, 0.436968,
    0.442329, 0.447703, 0.453090, 0.458490, 0.463903, 0.469330, 0.474771, 0.480226,
    0.485695, 0.491179, 0.496678, 0.502192, 0.507721, 0.513266, 0.518826, 0.524403,
    0.529995, 0.535605, 0.541231, 0.546875, 0.552536, 0.558215, 0.563912, 0.569627,
    0.575361, 0.581114, 0.586887, 0.592678, 0.598490, 0.604322, 0.610175, 0.616049,
    0.621944, 0.627861, 0.633799, 0.639761, 0.645745, 0.651752, 0.657783, 0.663838,
    0.669917, 0.676021, 0.682151, 0.688306, 0.694487, 0.700696, 0.706931, 0.713194,
    0.719484, 0.725804, 0.732153, 0.738531, 0.744939, 0.751379, 0.757849, 0.764352,
    0.770886, 0.777454, 0.784056, 0.790692, 0.797363, 0.804070, 0.810813, 0.817593,
    0.824411, 0.831268, 0.838163, 0.845099, 0.852076, 0.859095, 0.866156, 0.873260,
    0.880409, 0.887603, 0.894844, 0.902131, 0.909467, 0.916852, 0.924288, 0.931775,
    0.939314, 0.946908, 0.954556, 0.962261, 0.970023, 0.977844, 0.985725, 0.993668,
    1.001674, 1.009745, 1.017882, 1.026088, 1.034363, 1.042709, 1.051129, 1.059623,
    1.068195, 1.076846, 1.085579, 1.094395, 1.103297, 1.112288, 1.121369, 1.130543,
    1.139814, 1.149184, 1.158656, 1.168233, 1.177918, 1.187715, 1.197627, 1.207659,
    1.217813, 1.228095, 1.238508, 1.249057, 1.259748, 1.270584, 1.281571, 1.292716,
    1.304023, 1.315499, 1.327152, 1.338987, 1.351014, 1.363238, 1.375671, 1.388319,
    1.401194, 1.414305, 1.427664, 1.441282, 1.455174, 1.469352, 1.483832, 1.498630,
    1.513763, 1.529252, 1.545117, 1.561380, 1.578067, 1.595206, 1.612827, 1.630963,
    1.649653, 1.668938, 1.688864, 1.709485, 1.730859, 1.753056, 1.776152, 1.800237,
    1.825416, 1.851808, 1.879559, 1.908840, 1.939857, 1.972864, 2.008176, 2.046192,
    2.087426, 2.132561, 2.182530, 2.238661, 2.302941, 2.378551, 2.471121, 2.592296,
    2.774754,
};

float rng_gauss (const rng_unif rng_uniform)
{
    // Marsaglia polar method:
    static bool  set  = false;
    static float gset;
    float        fac, rsq, v1, v2;

    if (!set) {
        do {
            // v1/2 in U[-1, 1]
            v1 = ((*rng_uniform) ()) * 2 - 1;
            v2 = ((*rng_uniform) ()) * 2 - 1;

            rsq = v1*v1 + v2*v2;
        } while  (rsq >= 1.0f || rsq == 0.0f);

        fac = sqrtf (-2.0f * logf (rsq) / rsq);

        gset = v1 * fac;
        set = true;
        return v2 * fac;
    } else {
        set = false;
        return gset;
    }
}

/* New version based on Marsaglia and Tsang, "A Simple Method for
 * generating gamma variables", ACM Transactions on Mathematical
 * Software, Vol 26, No 3 (2000), p363-372.
 *
 * Implemented by J.D.Lamb@btinternet.com, minor modifications for GSL
 * by Brian Gough
 */
float rng_gamma (const rng_unif rng_uniform, const float a, const float b)
{
	/* assume a > 0 */
	if (a < 1) {
		float u = (*rng_uniform) ();
		return rng_gamma (rng_uniform, 1.0 + a, b) * powf (u, 1.0 / a);
	} else {
		float x, v, u;
		float d = a - 1.0 / 3.0;
		float c = (1.0 / 3.0) / sqrtf (d);

		for (;;) {
			do {
				x = rng_gauss (rng_uniform);
				v = 1.0 + c * x;
			}
			while (v <= 0);

			v = v * v * v;
			u = (*rng_uniform) ();

			if (u < 1 - 0.0331 * x * x * x * x)
				break;

			if (logf (u) < 0.5 * x * x + d * (1 - v + logf (v)))
				break;
		}

		return b * d * v;
	}
}

